<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HashMap详解 | lailai&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <script language="javascript" type="text/javascript" src="/js/pgmanor-self.js"></script>
    <meta name="description" content="我的个人网站">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="expires" cotent="0">
    <meta http-quiv="pragma" cotent="no-cache, must-revalidate">
    
    <link rel="preload" href="/assets/css/0.styles.05c4b953.css" as="style"><link rel="preload" href="/assets/js/app.0a5a6e72.js" as="script"><link rel="preload" href="/assets/js/3.a3d1b5e9.js" as="script"><link rel="preload" href="/assets/js/1.a5d05732.js" as="script"><link rel="preload" href="/assets/js/16.9e2cebfd.js" as="script"><link rel="prefetch" href="/assets/js/10.0e9b4a77.js"><link rel="prefetch" href="/assets/js/11.7f75b3d7.js"><link rel="prefetch" href="/assets/js/12.231273b7.js"><link rel="prefetch" href="/assets/js/13.adc6aeea.js"><link rel="prefetch" href="/assets/js/14.0f4aa7c8.js"><link rel="prefetch" href="/assets/js/15.942d1b09.js"><link rel="prefetch" href="/assets/js/17.ba169bfb.js"><link rel="prefetch" href="/assets/js/18.5ccdddba.js"><link rel="prefetch" href="/assets/js/19.24e604ff.js"><link rel="prefetch" href="/assets/js/20.22ab79f3.js"><link rel="prefetch" href="/assets/js/21.00d3baf2.js"><link rel="prefetch" href="/assets/js/22.0dde66e8.js"><link rel="prefetch" href="/assets/js/23.569e93e5.js"><link rel="prefetch" href="/assets/js/24.78d00497.js"><link rel="prefetch" href="/assets/js/25.3db86d41.js"><link rel="prefetch" href="/assets/js/4.403b3d1d.js"><link rel="prefetch" href="/assets/js/5.39e47282.js"><link rel="prefetch" href="/assets/js/6.837ab4ba.js"><link rel="prefetch" href="/assets/js/7.af111d70.js"><link rel="prefetch" href="/assets/js/8.3e94a0c8.js"><link rel="prefetch" href="/assets/js/9.404c9dae.js">
    <link rel="stylesheet" href="/assets/css/0.styles.05c4b953.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>lailai's blog</h3> <p class="description" data-v-59e6cb88>我的个人网站</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>lailai</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">lailai's blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      后端基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/1.html" class="nav-link"><i class="undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/utils/分布式锁工具类.html" class="nav-link"><i class="undefined"></i>
  工具类
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  其它链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具类/" class="nav-link"><i class="undefined"></i>
  工具类
</a></li><li class="dropdown-item"><!----> <a href="/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/others/" class="nav-link"><i class="undefined"></i>
  其他
</a></div><div class="nav-item"><a href="https://github.com/tacitjj" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <h3 class="name" data-v-1fad0c41>
    lailai
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>11</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>9</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      后端基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basic/1.html" class="nav-link"><i class="undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/utils/分布式锁工具类.html" class="nav-link"><i class="undefined"></i>
  工具类
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  其它链接
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/工具类/" class="nav-link"><i class="undefined"></i>
  工具类
</a></li><li class="dropdown-item"><!----> <a href="/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/others/" class="nav-link"><i class="undefined"></i>
  其他
</a></div><div class="nav-item"><a href="https://github.com/tacitjj" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>后端基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/basic/1.html" class="sidebar-link">首页</a></li><li><a href="/basic/hashmap.html" aria-current="page" class="active sidebar-link">HashMap详解</a></li><li><a href="/basic/JDK 1.8 内存结构.html" class="sidebar-link">JDK 1.8 内存结构</a></li><li><a href="/basic/2.html" class="sidebar-link">这个还不知道写什么</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>HashMap详解</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>lailai</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">HashMap详解</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>lailai</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>1/21/2023</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>java</span><span class="tag-item" data-v-8a445198>map</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> HashMap</h2> <p>[TOC]</p> <h3 id="_1-摘要"><a href="#_1-摘要" class="header-anchor">#</a> 1.摘要</h3> <p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8 对HashMap底层的实现进⾏了优化，例如引⼊红⿊树 的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构 实现和功能原理。</p> <h3 id="_2-简介"><a href="#_2-简介" class="header-anchor">#</a> 2.简介</h3> <p>Java为数据结构中的映射定义了⼀个接⼝java.util.Map ，此接⼝主要有四个常⽤的实现类， 分别是HashMap、Hashtable、LinkedHashMap 和TreeMap，类继承关系如下图所示：</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301221147780.png" alt="image-20230122114743732"></p> <p>下面针对各个实现类的特点做⼀些说明：</p> <p>(1) <strong>HashMap</strong> ：它根据键的hashCode值存储数据，⼤多数情况下可以直接定位到它的值， 因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许⼀条记录的键 为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满⾜线程安全，可以⽤ Collections的 synchronizedMap⽅法使HashMap具有线程安全的能⼒力力，或者使用ConcurrentHashMap。</p> <p>(2) <strong>Hashtable</strong> ：Hashtable 是遗留类，很多映射的常⽤功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任⼀时间只有一个线程能写Hashtable ，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引⼊了分段锁。</p> <div class="custom-block tip"><p class="title"></p><p>jdk1.8 中的 ConcurrentHashMap 中废弃了 Segment 锁，直接使用了数组元素，数组中的每个元素都可以作为一个锁。在元素中没有值的情况下，可以直接通过 CAS 操作来设值，同时保证并发安全；如果元素里面已经存在值的话，那么就使用 synchronized 关键字对元素加锁，再进行之后的 hash 冲突处理。</p></div><p>Hashtable不建议在新代码中使用，不需要线程安全的场合可以⽤HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap替换。</p> <p>(3) <strong>LinkedHashMap</strong> ：LinkedHashMap是HashMap的⼀个子类，保存了记录的插⼊顺序， 在⽤Iterator 遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p> <p>(4) <strong>TreeMap</strong> ：TreeMap 实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的⽐较器器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap 。在使用TreeMap 时，key必须实现 Comparable 接口或者在构造TreeMap传⼊自定义的Comparator ，否则会在运行时抛出 java.lang.ClassCastException类型的异常。</p> <p>对于上述四种Map类型的类，要求映射中的key是不可变对象。 <strong>不可变对象是该对象在创建后它的哈希值不会被改变</strong> 。如果对象的哈希值发⽣变化，Map对象很可能就定位不到映射的位置了。</p> <p>通过上面的⽐较，我们知了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使⽤条件，所以是使用频度最⾼的一个。下文我们主要结合源码，从存储结构、常用⽅法分析、扩容以及安全性等方面深入讲解HashMap的⼯作原理。</p> <h3 id="_3-内部实现"><a href="#_3-内部实现" class="header-anchor">#</a> 3.内部实现</h3> <p>搞清楚HashMap，⾸先需要知道HashMap是什么，即它的存储结构-字段；其次弄明⽩它能干什么，即它的功能实现-⽅法。下⾯我们针对这两个⽅⾯详细展开讲解。</p> <p><em>存储结构-字段</em></p> <div class="custom-block tip"><p class="title"></p><p>从结构实现来讲，HashMap是数组+链表+红⿊树（JDK1.8增加了红⿊树部分）实现 的，如下如所示。</p></div><p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301221146021.png" alt="image-20230122114651932"></p> <p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储⽅式有什么优点呢？</p> <p>(1) 从源码可知，HashMap类中有⼀个⾮常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>  <span class="token comment">//用来定位数组索引位置</span>
        <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
        <span class="token class-name">V</span> value<span class="token punctuation">;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>    <span class="token comment">//链表的下一个node</span>

        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>
            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>Node是HashMap的⼀个内部类，实现了Map.Entry接⼝，本质是就是⼀个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p> <p>(2) HashMap就是使⽤哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都⼀个链表结构，当数据被Hash后，得到数组下标，把数据 放在对应下标元素的链表上。例如程序执⾏下⾯代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;金金&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;小金&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>系统将调⽤&quot;金金&quot;这个key的hashCode()⽅法得到其hashCode 值（该⽅法适用于每个Java 对象），然后再通过Hash算法的后两步运算（⾼位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发⽣了Hash碰撞。当然 Hash算法计算结果越分散均匀，Hash碰撞的概率就越⼩，map的存取效率就会越高。</p> <p>如果哈希桶数组很大，即使较差的Hash算法也会⽐较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的⼤⼩，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么⽅式来控制map使得Hash碰撞的概率⼜小，哈希桶数组（Node[] table） 占⽤空间⼜少呢？答案就是好的Hash算法和扩容机制。</p> <p>在理解Hash和扩容流程之前，我们得先了解下HashMap 的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面⼏几个字段进行初始化，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * The number of key-value mappings contained in this map.
 */</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

<span class="token comment">/**
 * The number of times this HashMap has been structurally modified
 * Structural modifications are those that change the number of mappings in
 * the HashMap or otherwise modify its internal structure (e.g.,
 * rehash).  This field is used to make iterators on Collection-views of
 * the HashMap fail-fast.  (See ConcurrentModificationException).
 */</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

<span class="token comment">/**
 * The next size value at which to resize (capacity * load factor).
 *
 * @serial
 */</span>
<span class="token comment">// (The javadoc description is true upon serialization.</span>
<span class="token comment">// Additionally, if the table array has not been allocated, this</span>
<span class="token comment">// field holds the initial array capacity, or zero signifying</span>
<span class="token comment">// DEFAULT_INITIAL_CAPACITY.)</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>              <span class="token comment">//所容纳的key-value对极限</span>

<span class="token comment">/**
 * The load factor for the hash table.
 *
 * @serial
 */</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">//负载因子</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>⾸先，Node[] table的初始化长度length(默认值是16)，<code>loadFactor</code> 为负载因⼦(默认值是 0.75)，<code>threshold</code>是HashMap所能容纳的最大数据量的Node(键值对)个数。<code>threshold = length * loadFactor</code> 。也就是说，在数组定义好长度之后，负载因子越⼤，所能容纳的键值对个数越多。</p> <p>结合负载因⼦的定义公式可知，<code>threshold</code>就是在此<code>loadFactor</code> 和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因⼦0.75是对空间和时间效率的一个平衡选择，建议大家不要修改， 除非在时间和空间⽐较特殊的情况下，如果内存空间很多⽽⼜对时间效率要求很高，可以降低负载因子<code>loadFactor</code> 的值；相反，如果内存空间紧张而对时间效率要求不⾼，可以增加负载因⼦<code>loadFactor</code>的值，这个值可以大于1。</p> <p><code>size</code> 这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度 length、容纳最大键值对数量<code>threshold</code>的区别。⽽modCount 字段主要⽤来记录HashMap内部结构发生变化的次数，主要⽤于迭代的快速失败。强调一点，内部结构发⽣变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p> <p>在HashMap中，哈希桶数组table的长度length⼤⼩必须为2的n次方(⼀定是合数)，这是⼀种⾮常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，Hashtable初始化桶⼤⼩为11，就是桶⼤⼩设计为素数的应用（Hashtable 扩容 后不能保证还是素数）。HashMap采⽤这种⾮常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加⼊了高位参与运算的过程。</p> <p>这里存在一个问题，即使负载因⼦和Hash算法设计的再合理，也免不了会出现拉链过⻓的情况，⼀旦出现拉链过⻓，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进⼀步的优化，引入了红黑树。⽽当链表⻓度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap 的性能，其中会用到红黑树的插入、删除、查找等算法。</p> <h3 id="_4-功能实现-方法"><a href="#_4-功能实现-方法" class="header-anchor">#</a> 4.功能实现-方法</h3> <p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put⽅法的详细执行、扩容过程三个具有代表性的点深⼊展开讲解。</p> <h4 id="_4-1-确定哈希桶数组索引位置"><a href="#_4-1-确定哈希桶数组索引位置" class="header-anchor">#</a> 4.1 确定哈希桶数组索引位置</h4> <p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前⾯说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap⾥⾯的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有⼀个，那么当我们用hash算法求得这个位置的时候，⻢上就可以知道对应位置的元素就是我们要的，不用遍历链表，大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash⽅法的离散性能。先看源码的实现(<u>⽅法⼀</u>+<u>⽅法二</u>):</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token comment">//⽅法⼀：</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//jdk1.8 &amp; jdk1.7</span>
        
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>

        <span class="token comment">// h = key.hashCode() 为第⼀步 取hashCode值</span>
        <span class="token comment">// h ^ (h &gt;&gt;&gt; 16)     为第⼆步 高位参与运算</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//⽅法二：</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//jdk1.7的源码，jdk1.8没有这个⽅法，但是实现原理⼀样的</span>
        
        <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第三步 取模运算</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这⾥的Hash算法本质上就是三步： <strong>取key的hashCode值、⾼位运算、取模运算</strong>。</p> <p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调⽤<strong>⽅法⼀</strong>所计算得到的Hash码值总是相同的。我们⾸先想到的就是把hash值对数组⻓度取模运算，这样⼀来， 元素的分布相对来说是⽐较均匀的。但是，模运算的消耗还是⽐较大的，在HashMap中是这样做的：调⽤<strong>⽅法⼆</strong>来计算该对象应该保存在table数组的哪个索引处。</p> <p>这个⽅法⾮常巧妙，它通过 <code>h &amp; (table.length -1)</code> 来得到该对象的保存位，⽽ HashMap底层数组的⻓度总是2的n次⽅，这是HashMap在速度上的优化。当length总是2的 n次⽅时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;⽐%具有更⾼的 效率。</p> <div class="custom-block tip"><p class="title"></p><p>在JDK1.8的实现中，优化了⾼位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length⽐较⼩的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太⼤的开销。</p></div><p>下⾯举例说明下，n为table的⻓度。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301221145986.png" alt="image-20230122114543937"></p> <h4 id="_4-2-分析hashmap的put方法"><a href="#_4-2-分析hashmap的put方法" class="header-anchor">#</a> 4.2 分析hashMap的put方法</h4> <p>HashMap的put⽅法执⾏过程可以通过下图来理解，⾃己有兴趣可以去对⽐源码更清楚地研究学习。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301221143231.png" alt="img"></p> <p>①.判断键值对数组table[i]是否为空或为null，否则执⾏resize()进⾏扩容；</p> <p>②.根据键值key计算hash值得到插⼊的数组索引i，如果table[i]==null ，直接新建节点添 加，转向⑥，如果table[i]不为空，转向③；</p> <p>③.判断table[i]的⾸个元素是否和key⼀样，如果相同直接覆盖value，否则转向④，这⾥的相同指的是hashCode以及equals；</p> <p>④.判断table[i] 是否为treeNode，即table[i] 是否是红⿊树，如果是红⿊树，则直接在树中插⼊键值对，否则转向⑤；</p> <p>⑤.遍历table[i]，判断链表⻓度是否大于8，大于8的话把链表转换为红⿊树，在红⿊树中执⾏插⼊操作，否则进⾏链表的插⼊操作；遍历过程中若发现key已经存在直接覆盖value即可；</p> <p>⑥.插⼊成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进⾏扩容。</p> <p>JDK1.8HashMap的put⽅法源码如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">//对key的hashCode()做hash</span>
        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code>  <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//声明了一个局部变量 tab,局部变量 Node 类型的数据 p,int 类型 n,i</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    
    		<span class="token comment">// 步骤①：tab为空则创建</span>
        <span class="token comment">//首先将当前 hashmap 中的 table(哈希表)赋值给当前的局部变量 tab,然后判断tab 是不是空或者长度是不是 0,实际上就是判断当前 hashmap 中的哈希表是不是空或者长度等于 0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment">//如果是空的或者长度等于0,代表现在还没哈希表,所以需要创建新的哈希表,默认就是创建了一个长度为 16 的哈希表</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    		<span class="token comment">// 步骤②：计算index，并对null做处理</span>
        <span class="token comment">//将当前哈希表中与要插入的数据位置对应的数据取出来,(n - 1) &amp; hash])就是找当前要插入的数据应该在哈希表中的位置,如果没找到,代表哈希表中当前的位置是空的,否则就代表找到数据了, 并赋值给变量 p</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个新的数据,这个数据没有下一条,并将数据放到当前这个位置</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//代表要插入的数据所在的位置是有内容的</span>
        <span class="token comment">//声明了一个节点 e, 一个 key k</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
						<span class="token comment">// 步骤③：节点key存在，直接覆盖value</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">//如果当前位置上的那个数据的 hash 和我们要插入的 hash 是一样,代表没有放错位置</span>
            <span class="token comment">//如果当前这个数据的 key 和我们要放的 key 是一样的,实际操作应该是就替换值</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">//将当前的节点赋值给局部变量 e</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
          	<span class="token comment">// 步骤④：判断该链为红黑树</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token comment">//如果当前节点的 key 和要插入的 key 不一样,然后要判断当前节点是不是一个红黑色类型的节点</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果是就创建一个新的树节点,并把数据放进去</span>
          	<span class="token comment">// 步骤⑤：该链为链表</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">//如果不是树节点,代表当前是一个链表,那么就遍历链表</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果当前节点的下一个是空的,就代表没有后面的数据了</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个新的节点数据并放到当前遍历的节点的后面</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 重新计算当前链表的长度是不是超出了限制</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//超出了之后就将当前链表转换为树,注意转换树的时候,如果当前数组的长度小于MIN_TREEIFY_CAPACITY(默认 64),会触发扩容,我个人感觉可能是因为觉得一个节点下面的数据都超过8 了,说明 hash寻址重复的厉害(比如数组长度为 16 ,hash 值刚好是 0或者 16 的倍数,导致都去同一个位置),需要重新扩容重新 hash</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">//如果当前遍历到的数据和要插入的数据的 key 是一样,和上面之前的一样,赋值给变量 e,下面替换内容</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果当前的节点不等于空,</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token comment">//将当前节点的值赋值给 oldvalue</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment">//将当前要插入的 value 替换当前的节点里面值</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span><span class="token comment">//增加长度</span>
    		<span class="token comment">// 步骤⑥：超过最⼤容量 扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果当前的 hash表的长度已经超过了当前 hash 需要扩容的长度, 重新扩容,条件是 haspmap 中存放的数据超过了临界值(经过测试),而不是数组中被使用的下标</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><h4 id="_4-3-扩容机制"><a href="#_4-3-扩容机制" class="header-anchor">#</a> 4.3 扩容机制</h4> <p>扩容(resize) 就是重新计算容量，向HashMap对象⾥不停的添加元素，⽽HashMap对象内部的数组⽆法装载更多的元素时，对象就需要扩大数组的⻓度，以便能装⼊更多的元素。当然Java⾥的数组是⽆法⾃动扩容的，⽅法是使⽤⼀个新的数组代替已有的容量⼩的数组， 就像我们⽤⼀个⼩桶装⽔，如果想装更多的⽔，就得换大⽔桶。</p> <p>我们分析下resize的源码，鉴于JDK1.8融⼊了红⿊树，较复杂，为了便于理解我们仍然使⽤ JDK1.7的代码，好理解⼀些，本质上区别不大，具体区别后⽂再说。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//传⼊新的容量</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token comment">//引⽤扩容前的Entry数组</span>

    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//扩容前的数组大⼩如果已经达到最大(2^30)了</span>

    		threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> <span class="token comment">//修改阈值为int的最大值(2^31-1)，这 样以后就不会扩容了</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

 

			<span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//初始化⼀个新的Entry数组</span>
  
  	<span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//！！将数据转移到新的Entry数组⾥</span>
  
		table <span class="token operator">=</span> newTable<span class="token punctuation">;</span> <span class="token comment">//HashMap的table属性引⽤新的Entry数组</span>

		threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//修改阈值</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>这⾥就是使⽤⼀个容量更⼤的数组来代替已有的容量⼩的数组，transfer()⽅法将原有Entry 数组的元素拷⻉到新的Entry数组⾥。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>	<span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token comment">//src引⽤了旧的Entry数组</span>

    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//遍历旧的Entry数组</span>

      	<span class="token class-name">Entry</span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//取得旧Entry数组的每个元素</span>

 				<span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

          src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//释放旧Entry数组的对象引⽤（for循环后，旧的Entry数组不再引⽤任何对象）</span>

          <span class="token keyword">do</span> <span class="token punctuation">{</span>

            <span class="token class-name">Entry</span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//！！重新计算每个元素在数组中的位置</span>
            
            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//标记[1]</span>

            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">//将元素放在数组上</span>
            
            e <span class="token operator">=</span> next<span class="token punctuation">;</span>  <span class="token comment">//访问下⼀个Entry链上的元素</span>

          <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>
    
    <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>newTable[i]的引⽤赋给了e.next，也就是使⽤了单链表的头插⼊⽅式，同⼀位置上新元素 总会被放在链表的头部位置；这样先放在⼀个索引上的元素终会被放到Entry链的尾部(如果发⽣了hash冲突的话），这⼀点和Jdk1.8有区别，下⽂详解。在旧数组中同⼀条Entry链 上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p> <p>下⾯举个例⼦说明下扩容过程。假设了我们的hash算法就是简单的⽤keymod ⼀下表的大⼩（也就是数组的⻓度。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这⾥了。这⾥假设负载因⼦ loadFactor=1，即当键值对的实际大⼩size大于table的实际大⼩时进⾏扩容。接下来的三个步骤是哈希桶数组 resize 成4，然后所有的Node重新rehash的过程。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242117236.png" alt="image-20230124211737184"></p> <p>下⾯我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使⽤的是2次幂的扩展(指 ⻓度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明⽩这句话的意思，n为table的⻓度，图（a）表示扩容前的key1和key2两 种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例， 其中hash1是key1对应的哈希与⾼位运算结果。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242118765.png" alt="image-20230124211842725"></p> <p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在⾼位多1bit(红⾊)，因此 新的index就会发⽣这样的变化：</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242119179.png" alt="image-20230124211931144"></p> <p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看 看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原 索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242119114.png" alt="image-20230124211948086"></p> <p>这个设计确实⾮常的巧妙，既省去了重新计算hash值的时间，⽽且同时，由于新增的1bit 是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的 bucket了。这⼀块就是JDK1.8新增的优化点。有⼀点注意区别，JDK1.7中rehash的时候， 旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从 上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//haspmap 触发扩容的条件有两个,一个是当存放的数据超过临界值的时候会触发扩容,另外一个是当需要转成红黑树的时候,如果当前数组的长度小于 64,会触发扩容</span>
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//声明了一个 oldtab ,并且把当前(扩容前) hashmap里面的哈希表赋值过来,如果是第一次放数据,此时这两个其实都是空</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token comment">//获取当前(扩容前)哈希表的长度,如果是第一次的话,就是 0,否则就是扩容之前的哈希表的长度</span>
        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">//当前(扩容前)哈希表需要扩容时候的长度,其实这值就是哈希表的长度*加载因子的长度,如果是第一次放数据,就是 0</span>
        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
        <span class="token comment">//新的长度和新的扩容长度</span>
        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果是第一次的时候,这个长度是 0,所以不符合当前判断,如果大于 0 代表是原先的老哈希表长度已经超出限制了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//看看最新的长度是不是大于等于hashmap 对数组长度的最大限制</span>
                threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span><span class="token comment">//设置为默认的最大长度</span>
                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> 
                     oldCap <span class="token operator">&gt;=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>
                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//如果没有超出长度限制,新的数组长度等于老的数组长度*2(向左移动 1 位)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//如果当前的扩容长度大于 0,代表已经有哈希表</span>
            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//代表还没有哈希表,实际上就是第一次向 map 中放数据</span>
            newCap <span class="token operator">=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span><span class="token comment">//新的哈希表长度为当前map 的默认值</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//新的扩容长度为默认长度*默认的加载因子,这里算它的原因是为了不在后面放数据的时候每次都重新计算,因为每次都要算是不是应该扩容,如果不找变量接收,每次都要做数学运算</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果新的长度还是 0,则继续计算</span>
            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">?</span>
                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span><span class="token comment">//当前 hashma的扩容长度等于最新计算出来的扩容长度</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//根据最新的长度创建对应长度的哈希表,如果是首次创建,默认就是 16</span>
        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token comment">//将当前 hashmap 中的哈希表赋值为最新刚刚创建的哈希表</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果原老的哈希表有数据,需要将老的数据放到新的哈希表,如果是首次创建就不执行</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//遍历老的数组</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//取出当前遍历的位置上的第一个节点</span>
                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//如果当前节点没有后面的数据</span>
                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">//新的数组的最新的节点上的数据直接就是这个数据</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment">//判断是不是树节点,如果是 就重新对树进行分割,然后放到新的位置</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 创建两个链表,主要是因为基本上扩容的时候,部分数据会在原始位置,另外一部分数据会去向后遍历老数组的长度,比如原先是数组长度是 16,原先在 1 位置上面的数据,扩容到 32 后要么就还在 1,要么就应该去17,也就是向后移动原始长度(或者是扩容增加的长度)</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                        <span class="token keyword">do</span> <span class="token punctuation">{</span>
                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//首先将当前的下一个数据赋值给 e</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//符合应该在原始位置条件的创建一条链表</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//如果没有数据</span>
                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//当前节点就是一个头</span>
                                <span class="token keyword">else</span>
                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//否则当前的尾节点下一条数据就是 e</span>
                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//e 就成为了尾结点</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//代表不符合原始位置的条件,就创建另外一个链表,来存放另外一部分数据</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//如果没有数据</span>
                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//当前节点就是一个头</span>
                                <span class="token keyword">else</span>
                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//否则当前的尾节点下一条数据就是 e</span>
                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//e 就成为了尾结点</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果当前位置下一个数据不等于空,继续向下找</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span><span class="token comment">//遍历完成后,当前位置的数据为上面构建的应该在当前原始位置的链表数据</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span><span class="token comment">//将另外一部分数据直接放到后面的位置,位置为原始位置加上偏移量(因为扩容就是翻倍长度,所以偏移量就是原始的长度或者说是扩容增加的长度)</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span> <span class="token comment">//返回最新创建的那个哈希表</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br></div></div><h5 id="链表转红黑树"><a href="#链表转红黑树" class="header-anchor">#</a> 链表转红黑树</h5> <div class="language-java line-numbers-mode"><pre class="language-java"><code>  <span class="token comment">/**
     * Replaces all linked nodes in bin at index for given hash unless
     * table is too small, in which case resizes instead.
     */</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
      <span class="token comment">//如果当前哈希表是空的或者是哈希表的数组长度小于 64,则触发扩容,这也是 hashmap 扩容的第二个条件和方式</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span><span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>
                    tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242136540.png" alt="image-20230124213630513"></p> <p>hashmap扩容</p> <p>扩容前数组⻓度为8，扩容为原数组⻓度的2倍即16。 原来有⼀条链表在tab[2]的位置，扩 容以后仍然有⼀条链在tab[2]的位置，另外⼀条链在tab[2+8]即tab[10]的位置处。</p> <p>多线程情况，对hashmap进⾏put操作会引起resize，并可能会造成数组元素的丢失</p> <h4 id="_4-4-线程安全性"><a href="#_4-4-线程安全性" class="header-anchor">#</a> 4.4 线程安全性</h4> <p>在多线程使⽤场景中，应该尽量避免使⽤线程不安全的HashMap，⽽使⽤线程安全的 ConcurrentHashMap。那么为什么说HashMap 是线程不安全的，下⾯举例⼦说明在并发的 多线程使⽤场景中使⽤HashMap 可能造成死循环。代码例⼦如下(便于理解，仍然使⽤ JDK1.7的环境)：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span>， <span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">&quot;Thread1&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">&quot;Thread2&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> &quot;<span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>其中，map初始化为⼀个⻓度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说 当put第⼆个key的时候，map就需要进⾏resize 。</p> <p>通过设置断点让线程1和线程2同时debug到transfer⽅法(3.3⼩节代码块)的⾸⾏。注意此时 两个线程已经成功添加数据。放开thread1的断点⾄transfer ⽅法的“Entry next = e.next;” 这 ⼀⾏；然后放开线程2的的断点，让线程2进⾏resize 。结果如下图。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242142425.png" alt="image-20230124214223373"></p> <p>注意，Thread1 的 e 指向了key(3)，⽽next指向了key(7)，其在线程⼆rehash后，指向了线程⼆重组后的链表。</p> <p>线程⼀被调度回来执⾏，先是执⾏</p> <p>newTalbe[i] = e， 然后是e = next，导致了e指向了</p> <p>key(7)，⽽下⼀次循环的next = e.next导致了next指向了key(3)。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242143392.png" alt="image-20230124214336328"></p> <p>e.next = newTable[i] 导致 key(3).next 指向了key(7)。注意：此时的key(7).next 已经指向了 key(3)， 环形链表就这样出现了。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242144899.png" alt="image-20230124214422851"></p> <p>于是，当我们⽤线程⼀调⽤map.get(11)时，悲剧就出现了——Infinite Loop。</p> <h4 id="_5-jdk1-8与jdk1-7的性能对比"><a href="#_5-jdk1-8与jdk1-7的性能对比" class="header-anchor">#</a> 5.JDK1.8与JDK1.7的性能对⽐</h4> <p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法⾮常 好，那样的话，getKey⽅法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞⾮常 多，假如Hash算极其差，所有的Hash算法结果得出的索引位置⼀样，那样所有的键值对都 集中到⼀个桶中，或者在⼀个链表中，或者在⼀个红⿊树中，时间复杂度分别为O(n)和 O(lgn)。 鉴于JDK1.8做了多⽅⾯的优化，总体性能优于JDK1.7，下⾯我们从两个⽅⾯⽤例 ⼦证明这⼀点。</p> <p>Hash较均匀的情况</p> <p>为了便于测试，我们先写⼀个类Key，如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>

        <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Key</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> o<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token class-name">Key</span> key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Key</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>

        <span class="token keyword">return</span> value <span class="token operator">==</span> key<span class="token punctuation">.</span>value<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">return</span> value<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>这个类复写了equals⽅法，并且提供了相当好的hashCode函数，任何⼀个值的hashCode都 不会相同，因为直接使⽤value当做hashcode 。为了避免频繁的GC，我将不变的Key实例缓 存了起来，⽽不是⼀遍⼀遍的创建它们。代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Keys</span> <span class="token punctuation">{</span>

        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_KEY</span> <span class="token operator">=</span> <span class="token number">10_000_000</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Key</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">KEYS_CACHE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">[</span><span class="token constant">MAX_KEY</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token punctuation">{</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">MAX_KEY</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token constant">KEYS_CACHE</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Key</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">return</span> <span class="token constant">KEYS_CACHE</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、......10000000 ），屏蔽了扩容的情况，代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> mapSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">HashMap</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span>mapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mapSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Keys</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">long</span> beginTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取纳秒</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mapSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Keys</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>endTime <span class="token operator">-</span> beginTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1000</span> <span class="token number">0000</span><span class="token punctuation">;</span>
        i <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey 的平均时间，我们遍历所有的get⽅法，计算总的时间，除以key的数量，计算⼀个平均值，主要⽤来⽐较，绝对 值可能会受很多环境因素的影响。结果如下：</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242149853.png" alt="image-20230124214918822"></p> <p>通过观测测试结果可知，JDK1.8的性能要⾼于JDK1.7 15%以上，在某些size的区域上，甚 ⾄⾼于100%。由于Hash算法较均匀，JDK1.8引⼊的红⿊树效果不明显，下⾯我们看看 Hash不均匀的的情况。</p> <p>Hash极不均匀的情况</p> <p>假设我们⼜⼀个⾮常差的Key，它们所有的实例都返回相同的hashCode值。这是使⽤ HashMap最坏的情况。代码修改如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span> <span class="token comment">//...</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>仍然执⾏main⽅法，得出的结果如下表所示：</p> <p><img src="/Users/jinyingxin/Library/Application%20Support/typora-user-images/image-20230124215050700.png" alt="image-20230124215050700"></p> <p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增⻓的趋势，⽽JDK1.8 是明显 的降低趋势，并且呈现对数增⻓稳定。当⼀个链表太⻓的时候，HashMap会动态的将它替 换成⼀个红⿊树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所 花费的时间明显也不相同，这两种情况的相对⽐较，可以说明⼀个好的hash算法的重要性。</p> <h4 id="_6-小结"><a href="#_6-小结" class="header-anchor">#</a> 6. 小结</h4> <p>(1) 扩容是⼀个特别耗性能的操作，所以当程序员在使⽤HashMap 的时候，估算map的大⼩，初始化的时候给⼀个大致的数值，避免map进⾏频繁的扩容。</p> <p>(2) 负载因⼦是可以修改的，也可以大于1，但是建议不要轻易易修改，除⾮情况⾮常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使⽤ConcurrentHashMap。</p> <p>(4) JDK1.8引⼊红⿊树大程度优化了HashMap的性能。</p> <p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰⼭山⼀⻆角。</p> <h4 id="_7-hashmap的容量为什什么是2的幂次"><a href="#_7-hashmap的容量为什什么是2的幂次" class="header-anchor">#</a> 7. Hashmap的容量为什什么是2的幂次</h4> <div class="custom-block tip"><p class="title"></p><p>通过 JDK1.7更容易说明</p></div><div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将空key的Entry加⼊到table[0]中</span>

        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//计算key.hashcode()的hash值，hash函数由hashmap⾃己实现</span>


        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取将要存放的数组下标</span>
        <span class="token comment">/*
         * for中的代码⽤用于：当hash值相同且key相同的情况下，使⽤用新值覆盖旧值（其实就 是修改功能）
         */</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//注意：for 循环在第⼀次执行时就会先判断条件</span>
            <span class="token class-name">Object</span> k<span class="token punctuation">;</span>
            <span class="token comment">//hash值相同且key相同的情况下，使⽤新值覆盖旧值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token comment">//e.recordAccess(this);</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token comment">//返回旧值</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//增加一个新的Entry到table[i]</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//如果没有与传⼊的key相等的Entry，就返回null</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * &quot;按位与&quot;来获取数组下标
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>⾸先算得key得hashcode 值，然后跟数组的⻓度-1做⼀次“与”运算（&amp;）。看上去很简单， 其实⽐较有⽞玄机。⽐如数组的⻓度是2的4次⽅，那么hashcode 就会和2的4次⽅-1做“与”运 算。很多⼈人都有这个疑问，为什么hashmap 的数组初始化大⼩都是2的次⽅大⼩时， hashmap的效率最⾼，我以2的4次⽅举例，来解释⼀下为什么数组大⼩为2的幂时hashmap 访问的性能最⾼。</p> <p>看下图，左边两组是数组⻓度为16（2的4次⽅），右边两组是数组⻓度为15。两组的 hashcode 均为8和9，但是很明显，当它们和1110“与”的时候，产⽣生了相同的结果，也就是 说它们会定位到数组中的同⼀个位置上去，这就产⽣生了碰撞，8和9会被放到同⼀个链表 上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同 时，我们也可以发现，当数组⻓度为15的时候，hashcode 的值会与14（1110）进⾏“与”， 那么最后⼀位永远是0，⽽0001，0011，0101，1001，1011，0111，1101这⼏几个位置永远 都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使⽤的位置⽐数组 ⻓度⼩了很多，这意味着进⼀步增加了碰撞的⼏几率，减慢了查询的效率！</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242156235.png" alt="image-20230124215627204"></p> <p>所以说，当数组⻓度为2的n次幂的时候，不同的key算得得index相同的⼏几率较⼩，那么数 据在数组上分布就⽐较均匀，也就是说碰撞的⼏几率⼩，相对的，查询的时候就不⽤遍历某 个位置上的链表，这样查询效率也就较⾼了。说到这⾥，我们再回头看⼀下hashmap中 默认的数组大⼩是多少，查看源代码可以得知是16，为什么是16，⽽不是15，也不是20 呢，看到上⾯annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因， 在⼩数据量的情况下16⽐15和20更能减少key之间的碰撞，⽽加快查询的效率。</p> <h4 id="_8-hashmap扩容时死循环问题"><a href="#_8-hashmap扩容时死循环问题" class="header-anchor">#</a> 8.hashmap扩容时死循环问题</h4> <div class="custom-block tip"><p class="title"></p><p>此问题在JDK1.8时候解决</p></div><p>大家都知道，hashmap不能⽤于多线程场景中，多线程下推荐使⽤concurrentHashmap ！ 但为什么多线程下不能使⽤hashmap那，主要原因就在于其的扩容机制。故事的起源从 hashmap的数据存放开始说起，默认hashmap大⼩是16.当数据过大时，毫⽆疑问， hashmap需要扩容去支持存放更多的数据。 源码如下 ——–Put⼀个Key,Value对到Hash表 中：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

        <span class="token comment">//计算Hash值</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//各种校验吧</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Object</span> k<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">//该key不存在，需要增加⼀个结点</span>
        <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>这⾥添加⼀个节点需要检查是否超出容量，出现了⼀个负载因⼦。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize if (size++ &gt;= threshold)</span>
    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//扩容都是2倍2倍的来的，</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>⾄于为什么扩容都是2的幂次⽅这个问题,看上⾯。</p> <p>既然新建了⼀个更⼤尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">//创建⼀个新的Hash Table</span>
        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将Old Hash Table上的数据迁移到New Hash Table上transfer(newTable);</span>
        table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>
        threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>好，重点在这⾥面的transfer()!</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 下⾯这段代码的意思是：</span>
        <span class="token comment">// 从OldTable⾥摘⼀个元素出来，然后放到NewTable中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">do</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                    e <span class="token operator">=</span> next<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>do循环⾥面的是最能说明问题的 当只有⼀个线程的时候：</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242209106.png" alt="image-20230124220940084"></p> <p>图上的hash算法是⾃定义的，不要纠结这个，是简单的⽤keymod ⼀下表的大⼩（也就是 数组的⻓度）。不是那个实际的hash算法！ 最上⾯的是old hash 表，其中的Hash表的 size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这⾥了。接下来的三个步骤是Hash 表 扩容变成4，然后所有的</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// &lt;--假设线程一执行到这里就被调度挂起了</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    e <span class="token operator">=</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242210155.png" alt="image-20230124221036120"></p> <p>⽽我们的线程⼆执⾏完成了。于是我们有下⾯的这个样⼦。</p> <p>注意，因为Thread1的 e 指向了key(3)，⽽next指向了key(7)，其在线程⼆rehash后，指向了线程⼆重组后的链表。我们可以看到链表的顺序被反转后。 这⾥的意思是线程1这会还没 有完全开始扩容，但e和next已经指向了，线程2是正常的扩容的，那这会在3这个位置上， 就是7-&gt;3这个顺序。 然后： 2）线程⼀被调度回来执⾏。</p> <p>先是执⾏newTalbe[i] = e; 然后是e = next，导致了e指向了key(7)， ⽽下⼀次循环的next =e.next导致了next指向了key(3) 注意看图⾥面的线，线程1指向线程2⾥面的key3.</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242211802.png" alt="image-20230124221141779"></p> <p>回到线程1⾥面的时候 3）⼀切安好。线程⼀接着⼯工作。把key(7) 摘下来，放到newTable[i]的第⼀个，然后把e和next往下移。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242213243.png" alt="image-20230124221315219"></p> <p>这时候，原来的线程2⾥面的key7的e和key3的next没了，e=key3,next=null 。</p> <p>4）环形链接出现。 当继续执⾏，需要将key3加回到key7的前⾯。 e.next = newTable[i] 导 致 key(3).next 指向了key(7)</p> <p>注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p> <p><img src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301242216792.png" alt="image-20230124221619747"></p> <p>我理解是线程2⽣生成的e和next的关系影响到了线程1⾥面的情况。从⽽打乱了正常的e和 next的链。</p> <p>于是，当我们的线程⼀调⽤到，HashTable.get(11)时，即⼜到了3这个位置，需要插⼊新 的，那这会就e 和next就乱了。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/basic/1.html" class="prev">
          首页
        </a></span> <span class="next"><a href="/basic/JDK 1.8 内存结构.html">
          JDK 1.8 内存结构
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/basic/hashmap.html#hashmap" class="sidebar-link reco-side-hashmap" data-v-b57cc07c>HashMap</a></li><li class="level-3" data-v-b57cc07c><a href="/basic/hashmap.html#_1-摘要" class="sidebar-link reco-side-_1-摘要" data-v-b57cc07c>1.摘要</a></li><li class="level-3" data-v-b57cc07c><a href="/basic/hashmap.html#_2-简介" class="sidebar-link reco-side-_2-简介" data-v-b57cc07c>2.简介</a></li><li class="level-3" data-v-b57cc07c><a href="/basic/hashmap.html#_3-内部实现" class="sidebar-link reco-side-_3-内部实现" data-v-b57cc07c>3.内部实现</a></li><li class="level-3" data-v-b57cc07c><a href="/basic/hashmap.html#_4-功能实现-方法" class="sidebar-link reco-side-_4-功能实现-方法" data-v-b57cc07c>4.功能实现-方法</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="https://cdn.jsdelivr.net/gh/tacitjj/picture/image/loser.m4a" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:80px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="https://p1.music.126.net/qTSIZ27qiFvRoKj-P30BiA==/109951165895951287.jpg?param=200y200" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(https://p1.music.126.net/qTSIZ27qiFvRoKj-P30BiA==/109951165895951287.jpg?param=200y200);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>LOSER</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>米津玄師</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/assets/js/app.0a5a6e72.js" defer></script><script src="/assets/js/3.a3d1b5e9.js" defer></script><script src="/assets/js/1.a5d05732.js" defer></script><script src="/assets/js/16.9e2cebfd.js" defer></script>
  </body>
</html>
