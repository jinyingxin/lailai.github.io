(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{426:function(t,a,s){"use strict";s.r(a);var r=s(2),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"jdk-1-8-内存结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk-1-8-内存结构"}},[t._v("#")]),t._v(" JDK 1.8 内存结构")]),t._v(" "),a("p",[t._v("[TOC]")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301192258962.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"程序计数器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[t._v("#")]),t._v(" 程序计数器")]),t._v(" "),a("p",[t._v("《深入理解java虚拟机》")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301192300707.png",alt:""}})]),t._v(" "),a("p",[t._v("记录当前线程执行的字节码行号。")]),t._v(" "),a("p",[t._v("① 线程私有。")]),t._v(" "),a("p",[t._v("② 如果执行的是native方法，值为null。")]),t._v(" "),a("p",[t._v("③ 此区域是JVM规范中唯一一个不存在OOM（OutOfMemory）的区域。")]),t._v(" "),a("h2",{attrs:{id:"虚拟机栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[t._v("#")]),t._v(" 虚拟机栈")]),t._v(" "),a("p",[t._v("每一个线程执行时，都对应有一个虚拟机栈，生命周期与线程相同。一个虚拟机栈有一个一个的栈帧组成，每个java方法被调用时都会创建一个栈帧，然后入栈，方法结束后出栈。一个栈帧由局部变量表，操作数栈，动态链接和方法出口信息组成。")]),t._v(" "),a("p",[t._v("如果方法中出现递归调用死循环，或者栈帧大小超过虚拟机栈限制都会抛出StackOverflowError；")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/tacitjj/picture/image/202301192258308.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"本地方法栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[t._v("#")]),t._v(" 本地方法栈")]),t._v(" "),a("p",[t._v("功能与虚拟机栈差不多，只不过本地方法栈是虚拟机在调用native方法时使用。")]),t._v(" "),a("h2",{attrs:{id:"堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),a("p",[t._v("堆是JVM占用比例最大的一块区域，用来存放对象实例。现代JVM大多将堆分为老年代和新生代。老年代与新生代比例为2：1。新生代分为一个Eden(伊甸园)和两个Survivor(幸存者区)区域，比例为8：1：1。")]),t._v(" "),a("p",[t._v("JDK1.7之后，运行时常量池从方法区中移入到堆中，存放一些符号引用。")]),t._v(" "),a("p",[a("code",[t._v("Class对象和static成员变量，两者都位于堆（Heap），且static 成员变量位于 Class对象内。（在jdk1.7及以前 static成员变量是在方法区中，1.8改名元空间）")])]),t._v(" "),a("h2",{attrs:{id:"元数据区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元数据区"}},[t._v("#")]),t._v(" 元数据区")]),t._v(" "),a("p",[t._v("在JDK1.7的时候，有一个JVM内存区域中有一块"),a("strong",[t._v("方法区")]),t._v("，主要存放虚拟机加载的类信息，静态变量，常量等。")]),t._v(" "),a("p",[t._v("JDK1.8时，移除了方法区的概念，用一个元数据区代替。元数据区存放的东西和方法区大致相同（没有静态变量），不过元数据区移动到本地内存中。"),a("strong",[t._v("本地内存")]),t._v("，又称堆外内存（Direct Memory），就是指机器内存中不是JVM管理的那部分内存，由操作系统管理。元数据区移动到本地内存以后，可以避免虚拟机加载类过多而引发的内存溢出：java.lang.OutOfMemoryError: PermGen，但是同样不能无限扩展。")]),t._v(" "),a("h2",{attrs:{id:"常量池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常量池"}},[t._v("#")]),t._v(" 常量池")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[a("strong",[t._v("class文件常量池（静态常量池）：")]),t._v(" 存储区域是在堆中，编译时产生对应的class文件，主要包含字面量和符号引用")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("运行时常量池：")]),t._v(" 存在与本地内存的元空间中，JVM运行时，在类加载完成后，将每个class常量池中的符号引用转换为直接引用，与全量池中保持一致")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[t._v("字符串常量池：")]),t._v(" 类在加载完成，经过验证，准备之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用只存储到sting pool中，string pool是一个StringTable类，是哈希表结果，里面存储的是字符串引用，具体的实例对象存储在堆中，这个stringtable表在每个hotspot中的实例只有一份，被所有类共享。")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);